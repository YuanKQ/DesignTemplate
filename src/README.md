一份好的代码应该具有以下特点：
- 可维护性：只更改我需要更改的代码， 其他代码不受影响。 一个Ability内部的改变，不影响其他Ability的代码。
- 可复用性：已有的代码可以复用。 Ability提供的功能点是可复用的。
- 可拓展性：能够很轻松添加新功能，对已有的代码的改动比较少。 比如，新的需求来了，我新加一个Ability即可。
- 灵活性



学习步骤：
- 第一遍：边想边看书．
- 第二遍：自己想一个适用该设计模式的场景，并用代码表达出来．
- 第三遍：抽象出ＵＭＬ类图和时序图．


一个很好的学习链接: 
https://design-patterns.readthedocs.io/zh_CN/latest/index.html
https://www.kancloud.cn/sstd521/design/193624

## 设计模式大PK
### 模板方法模式　VS. 建造者模式
#### 区别
模板方法模式是行为型模式，而建造者模式是创建型模式。

行为型模式设计到算法和对象间的职责分配，不仅描述对象或类的模式，还描述它们之间的通信方式，刻划了运行时难以跟踪的复杂的控制流，它们将你的注意力从控制流转移到对象间的关系上来。

创建型模式抽象了实例化过程。他们帮助一个系统独立于如何创建、组合和表示他的那些对象。

也就是说，模板方法模式是用来控件对象和类的通信等的，而建造者模式是用来创建对象的。

在实现方法的骨架层次上，建造者模式中使用的是组合的方式，而模板方法模式采用的是继承的方式，我们都知道，组合优于继承，所以我认为建造者更灵活，而且也可以避免由继承而引发的各种问题，如代码膨涨，责任过大，难以维护等。

#### 联系
建造者模式同样体现着模板方法，因为Builder类中定义好了ConcreteBuilder必须要重写或要有的方法也就是说Builder中已定义好了要有的方法，这些方法可以在Builder类中实现，也可以把它推迟到子类中实现。用回以上的两个例子，模板方法中Abstract2类的重要函数TemplateMethod与建造者模式中的Director类中的函数Build相似，都是定义了方法的执行的骨架。

### 工厂方法模式 VS. 建造者模式
#### 意图不同

在工厂方法模式里，我们关注的是一个产品整体，如超人整体，无须关心产品的各部分是如何创建出来的；但在建造者模式中，一个具体产品的产生是依赖各个部件的产生以及装配顺序，它关注的是“由零件一步一步地组装出产品对象”。简单地说，工厂模式是一个对象创建的粗线条应用，建造者模式则是通过细线条勾勒出一个复杂对象，关注的是产品组成部分的创建过程。

#### 产品的复杂度不同
工厂方法模式创建的产品一般都是单一性质产品，如成年超人，都是一个模样，而建造者模式创建的则是一个复合产品，它由各个部件复合而成，部件不同产品对象当然不同。这不是说工厂方法模式创建的对象简单，而是指它们的粒度大小不同。一般来说，工厂方法模式的对象粒度比较粗，建造者模式的产品对象粒度比较细。

### 状态模式　VS. 责任链模式